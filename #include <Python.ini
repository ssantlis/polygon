#include <Python.h> 
#include <iostream> 
#include <vector> 
#include <algorithm> 
using namespace std; 
 
vector<string> genDataSet() { 
    // Инициализация Python 
 
    Py_Initialize(); 
 
    // Импортируем ваш модуль 
    PyObject* pModule = PyImport_ImportModule("generate_dataset"); 
    if (!pModule) { 
        PyErr_Print(); 
        std::cerr << "Не удалось загрузить модуль!" << std::endl; 
        //return 1; 
    } 
 
    // Вызываем вашу функцию для генерации текстового датасета 
    PyObject* pFunc = PyObject_GetAttrString(pModule, "generate_text_dataset"); 
    if (!pFunc || !PyCallable_Check(pFunc)) { 
        PyErr_Print(); 
        std::cerr << "Не удалось загрузить функцию!" << std::endl; 
        //return -1; 
    } 
 
    // Создайте параметры для функции 
    PyObject* args = PyTuple_Pack(5, 
        PyLong_FromLong(10),  // num_rows 
        PyLong_FromLong(50),    // num_unique 
        PyLong_FromLong(10),    // max_length 
        PyLong_FromLong(1),     // enter 
        PyUnicode_FromString("abcdefghijklmnopqrstuvwxyz"));  // charset 
 
    // Вызовите функцию 
    PyObject* pGen = PyObject_CallObject(pFunc, args); 
    if (!pGen) { 
        PyErr_Print(); 
        std::cerr << "Не удалось вызвать функцию!" << std::endl; 
        //return 1; 
    } 
    vector<string> result = {}; 
    // Извлечение значений из генератора 
    while (true) { 
        PyObject* item = PyObject_CallMethod(pGen, "__next__", nullptr);  // Получаем следующее значение 
        if (item == nullptr) break;  // Выход, если генератор исчерпан 
 
        if (item == Py_None) { 
            // Если item равен None, добавляем пустую строку 
            result.push_back(""); // Добавляем пустую строку для null 
        } 
        else { 
            const char* str = PyUnicode_AsUTF8(item); 
            if (str) { 
                result.push_back(str); // Добавляем строку в вектор 
            } 
        } 
        //const char* str = PyUnicode_AsUTF8(item);  // Преобразуем элемент в строку 
        //result.push_back(str); 
        //std::cout << str << std::endl;  // Выводим значение 
        Py_DECREF(item);  // Освобождаем объект 
    } 
     
    // Освобождение ресурсов 
    Py_DECREF(pGen); 
    Py_DECREF(args); 
    Py_DECREF(pFunc); 
    Py_DECREF(pModule); 
    Py_Finalize(); 
    return result; 
} 
void copyVectorToArray(const std::vector<string>& vec, string arr[], size_t size) { 
    // Проверка, что размер массива соответствует размеру вектора 
    if (size < vec.size()) { 
        std::cerr << "Error: Array size is too small!" << std::endl; 
        return; 
    } 
 
    // Копирование элементов из вектора в массив 
    for (size_t i = 0; i < vec.size(); ++i) { 
        arr[i] = vec[i]; 
    } 
} 
int main() { 
    vector<string> arr = genDataSet(); 
    cout << "Сгенерированные значения: " << std::endl; 
    for (string value : arr) { 
        std::cout << value << std::endl;  // Выводим значение 
    } 
//    /*const int size = 500; 
//    string arr[size] = {}; 
//    copyVectorToArray(result, arr, sizeof(arr) / sizeof(arr[0])); 
//*/ 
// 
//    // Сортируем массив 
//    sort(arr.begin(), arr.end()); 
//    cout << "\n\n\n"; 
//    for (string value : arr) { 
//        cout << value << " "; 
//    } 
//    // Вектор для хранения уникальных значений 
//    vector<string> unique_values; 
// 
//    // Проходим по отсортированному массиву и добавляем уникальные значения 
//    for (int i = 0; i < arr.size(); i++) { 
//        // Добавляем только если это первый элемент или элемент не равен предыдущему 
//        if (i == 0 || arr[i] != arr[i - 1]) { 
//            unique_values.push_back(arr[i]); 
//        } 
//    } 
// 
//    //// Вывод результата 
//    //cout << "Уникальные значения: "; 
//    //for (string value : unique_values) { 
//    //    cout << value << " "; 
//    //} 
//    //cout << endl; 
 
    return 0; 
}